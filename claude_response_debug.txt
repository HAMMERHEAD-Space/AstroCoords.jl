```json
{
  "reasoning": "DIFFERENTIAL ANALYSIS:\n\n1. ISSUE: The reported issue is \"Code Coverage is somewhat low, it should be increased and try and get it to 100%\". Looking at the repository structure and test files, the issue is that not all code paths are being exercised by the test suite.\n\n2. PASSING vs FAILING: Looking at the test files provided:\n   - test/runtests.jl includes tests for anomalies, quantities, coordinate changes, J2EqOE, EDromo, KS, StiefelScheifele\n   - test/runtests.jl includes differentiation tests, JET tests, alloc tests, and Aqua tests\n   - However, examining the source files provided, I notice several functions that are NOT being tested:\n     * In src/anomalies.jl: All anomaly conversion functions appear to have tests\n     * In src/quantities.jl: meanMotion, orbitalPeriod, orbitalNRG functions have overloads that take AstroCoord\n     * In src/attitude_changes.jl: EP2MRP and MRP2EP functions for attitude coordinate conversions\n     * In src/utils.jl: angle_between_vectors function\n     * In src/regularized_config.jl: RegularizedCoordinateConfig constructors and helper functions\n     * In src/core_types.jl: Various type system functions like convert, zeros, etc.\n\n3. PATTERN: The common factor is that utility functions, type system methods, and attitude coordinate transformations are likely not covered by existing tests. The test suite focuses on orbital coordinate transformations but misses:\n   - Attitude coordinate transformations (EP2MRP, MRP2EP)\n   - Utility functions (angle_between_vectors)\n   - Quantity calculation functions with AstroCoord inputs\n   - RegularizedCoordinateConfig edge cases\n   - Type system edge cases (zeros, convert, etc.)\n\n4. ROOT CAUSE: Missing test coverage for:\n   - src/attitude_changes.jl (EP2MRP, MRP2EP) - no tests exist\n   - src/utils.jl (angle_between_vectors) - no tests exist\n   - src/quantities.jl (AstroCoord overloads) - likely partial coverage\n   - src/regularized_config.jl - likely partial coverage\n   - src/core_types.jl - type system methods not tested\n\n5. WHY IT FAILS: The test suite in test/runtests.jl doesn't include test files for attitude_changes, utils, or comprehensive tests for quantities with AstroCoord inputs. The @testset structure shows tests for coordinate changes and specific coordinate systems, but not for these utility modules.\n\n6. MY FIX: Add new test files to increase coverage:\n   - test/test_attitude_changes.jl for EP2MRP and MRP2EP\n   - test/test_utils.jl for angle_between_vectors\n   - Enhance test/test_quantities.jl to test AstroCoord overloads\n   - Add edge case tests for RegularizedCoordinateConfig\n   - Add type system tests\n\n7. VALIDATION: The new tests will:\n   - Exercise previously untested code paths\n   - Not break existing tests (they're additive)\n   - Use the same testing patterns as existing tests\n   - Follow the @testset structure already in place",
  "test_script": "using AstroCoords\\nusing Test\\nusing LinearAlgebra\\nusing StaticArrays\\n\\n# Test that currently PASSES - existing coordinate conversions\\n@testset \\\"Existing Coverage (Passes)\\\" begin\\n    cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n    μ = 398600.4418\\n    kep = Keplerian(cart, μ)\\n    @test kep isa Keplerian\\n    @test kep.a > 0\\nend\\n\\n# Test that currently FAILS (no coverage) - attitude changes\\n@testset \\\"Missing Coverage (Fails - not tested)\\\" begin\\n    # These functions exist but are NOT tested\\n    β = SVector{4}(0.5, 0.5, 0.5, 0.5)\\n    σ = EP2MRP(β)\\n    @test σ isa SVector{3}\\n    \\n    β_back = MRP2EP(σ)\\n    @test β_back isa SVector{4}\\n    \\n    # angle_between_vectors is NOT tested\\n    v1 = [1.0, 0.0, 0.0]\\n    v2 = [0.0, 1.0, 0.0]\\n    angle = angle_between_vectors(v1, v2)\\n    @test angle ≈ π/2 atol=1e-10\\n    \\n    # Quantity functions with AstroCoord input NOT fully tested\\n    cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n    μ = 398600.4418\\n    n = meanMotion(cart, μ)\\n    @test n > 0\\n    \\n    T = orbitalPeriod(cart, μ)\\n    @test T > 0\\n    \\n    E = orbitalNRG(cart, μ)\\n    @test E < 0\\nend\\n\\nprintln(\\\"Test validation complete\\\")\\n",
  "analysis": "Add comprehensive test files for attitude_changes, utils, and quantities to increase code coverage to 100%",
  "files": {
    "test/test_attitude_changes.jl": "using AstroCoords\\nusing Test\\nusing StaticArrays\\n\\n@testset \\\"Attitude Coordinate Conversions\\\" begin\\n    @testset \\\"EP2MRP\\\" begin\\n        # Test identity rotation\\n        β_identity = SVector{4}(1.0, 0.0, 0.0, 0.0)\\n        σ_identity = EP2MRP(β_identity)\\n        @test σ_identity ≈ SVector{3}(0.0, 0.0, 0.0) atol=1e-14\\n\\n        # Test 90 degree rotation about z-axis\\n        β_90z = SVector{4}(√2/2, 0.0, 0.0, √2/2)\\n        σ_90z = EP2MRP(β_90z)\\n        @test σ_90z[1] ≈ 0.0 atol=1e-14\\n        @test σ_90z[2] ≈ 0.0 atol=1e-14\\n        @test σ_90z[3] > 0.0\\n\\n        # Test arbitrary rotation\\n        β = SVector{4}(0.5, 0.5, 0.5, 0.5)\\n        σ = EP2MRP(β)\\n        @test σ isa SVector{3}\\n        @test all(isfinite.(σ))\\n\\n        # Test near -1 case (shadow set)\\n        β_near_neg1 = SVector{4}(-0.99, 0.1, 0.05, 0.05)\\n        β_near_neg1 = β_near_neg1 / norm(β_near_neg1)\\n        σ_near_neg1 = EP2MRP(β_near_neg1)\\n        @test all(isfinite.(σ_near_neg1))\\n    end\\n\\n    @testset \\\"MRP2EP\\\" begin\\n        # Test identity (zero MRP)\\n        σ_identity = SVector{3}(0.0, 0.0, 0.0)\\n        β_identity = MRP2EP(σ_identity)\\n        @test β_identity ≈ SVector{4}(1.0, 0.0, 0.0, 0.0) atol=1e-14\\n\\n        # Test arbitrary MRP\\n        σ = SVector{3}(0.1, 0.2, 0.3)\\n        β = MRP2EP(σ)\\n        @test β isa SVector{4}\\n        @test norm(β) ≈ 1.0 atol=1e-14\\n\\n        # Test large MRP (shadow set)\\n        σ_large = SVector{3}(2.0, 1.0, 0.5)\\n        β_large = MRP2EP(σ_large)\\n        @test norm(β_large) ≈ 1.0 atol=1e-14\\n    end\\n\\n    @testset \\\"Round-trip conversions\\\" begin\\n        # Test EP -> MRP -> EP\\n        β_orig = SVector{4}(0.6, 0.4, 0.5, 0.5)\\n        β_orig = β_orig / norm(β_orig)\\n        σ = EP2MRP(β_orig)\\n        β_back = MRP2EP(σ)\\n        @test β_back ≈ β_orig atol=1e-12\\n\\n        # Test MRP -> EP -> MRP\\n        σ_orig = SVector{3}(0.1, 0.2, 0.15)\\n        β = MRP2EP(σ_orig)\\n        σ_back = EP2MRP(β)\\n        @test σ_back ≈ σ_orig atol=1e-12\\n\\n        # Test with different types\\n        β_f32 = SVector{4}(0.5f0, 0.5f0, 0.5f0, 0.5f0)\\n        σ_f32 = EP2MRP(β_f32)\\n        @test σ_f32 isa SVector{3, Float32}\\n    end\\nend\\n",
    "test/test_utils.jl": "using AstroCoords\\nusing Test\\nusing LinearAlgebra\\n\\n@testset \\\"Utility Functions\\\" begin\\n    @testset \\\"angle_between_vectors\\\" begin\\n        # Test orthogonal vectors\\n        v1 = [1.0, 0.0, 0.0]\\n        v2 = [0.0, 1.0, 0.0]\\n        angle = angle_between_vectors(v1, v2)\\n        @test angle ≈ π/2 atol=1e-10\\n\\n        # Test parallel vectors\\n        v1 = [1.0, 0.0, 0.0]\\n        v2 = [2.0, 0.0, 0.0]\\n        angle = angle_between_vectors(v1, v2)\\n        @test angle ≈ 0.0 atol=1e-10\\n\\n        # Test anti-parallel vectors\\n        v1 = [1.0, 0.0, 0.0]\\n        v2 = [-1.0, 0.0, 0.0]\\n        angle = angle_between_vectors(v1, v2)\\n        @test angle ≈ π atol=1e-10\\n\\n        # Test 45 degree angle\\n        v1 = [1.0, 0.0, 0.0]\\n        v2 = [1.0, 1.0, 0.0]\\n        angle = angle_between_vectors(v1, v2)\\n        @test angle ≈ π/4 atol=1e-10\\n\\n        # Test arbitrary 3D vectors\\n        v1 = [1.0, 2.0, 3.0]\\n        v2 = [4.0, 5.0, 6.0]\\n        angle = angle_between_vectors(v1, v2)\\n        # Verify using dot product formula\\n        expected = acos(dot(v1, v2) / (norm(v1) * norm(v2)))\\n        @test angle ≈ expected atol=1e-10\\n\\n        # Test with different numeric types\\n        v1_f32 = Float32[1.0, 0.0, 0.0]\\n        v2_f32 = Float32[0.0, 1.0, 0.0]\\n        angle_f32 = angle_between_vectors(v1_f32, v2_f32)\\n        @test angle_f32 ≈ π/2 atol=1e-6\\n\\n        # Test mixed types\\n        v1_f64 = [1.0, 0.0, 0.0]\\n        v2_f32 = Float32[0.0, 1.0, 0.0]\\n        angle_mixed = angle_between_vectors(v1_f64, v2_f32)\\n        @test angle_mixed ≈ π/2 atol=1e-6\\n\\n        # Test with normalized vectors\\n        v1_norm = normalize([1.0, 1.0, 1.0])\\n        v2_norm = normalize([1.0, -1.0, 0.0])\\n        angle_norm = angle_between_vectors(v1_norm, v2_norm)\\n        @test 0.0 <= angle_norm <= π\\n        @test isfinite(angle_norm)\\n\\n        # Test near-zero vectors (edge case)\\n        v1_small = [1e-10, 0.0, 0.0]\\n        v2_small = [0.0, 1e-10, 0.0]\\n        angle_small = angle_between_vectors(v1_small, v2_small)\\n        @test angle_small ≈ π/2 atol=1e-8\\n    end\\nend\\n",
    "test/test_quantities_extended.jl": "using AstroCoords\\nusing Test\\nusing LinearAlgebra\\n\\n@testset \\\"Quantity Functions Extended\\\" begin\\n    μ = 398600.4418  # Earth's gravitational parameter\\n\\n    @testset \\\"meanMotion with AstroCoord\\\" begin\\n        # Test with Cartesian\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        n = meanMotion(cart, μ)\\n        @test n > 0\\n        @test isfinite(n)\\n\\n        # Test with Keplerian\\n        kep = Keplerian(7000.0, 0.01, 0.0, 0.0, 0.0, 0.0)\\n        n = meanMotion(kep, μ)\\n        @test n > 0\\n        @test isfinite(n)\\n\\n        # Compare direct calculation with AstroCoord\\n        a = 7000.0\\n        n_direct = meanMotion(a, μ)\\n        n_coord = meanMotion(kep, μ)\\n        @test n_direct ≈ n_coord atol=1e-10\\n    end\\n\\n    @testset \\\"orbitalPeriod with AstroCoord\\\" begin\\n        # Test with Cartesian\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        T = orbitalPeriod(cart, μ)\\n        @test T > 0\\n        @test isfinite(T)\\n\\n        # Test with Keplerian\\n        kep = Keplerian(7000.0, 0.01, 0.0, 0.0, 0.0, 0.0)\\n        T = orbitalPeriod(kep, μ)\\n        @test T > 0\\n        @test isfinite(T)\\n\\n        # Compare direct calculation with AstroCoord\\n        a = 7000.0\\n        T_direct = orbitalPeriod(a, μ)\\n        T_coord = orbitalPeriod(kep, μ)\\n        @test T_direct ≈ T_coord atol=1e-8\\n\\n        # Verify relationship: T = 2π/n\\n        n = meanMotion(kep, μ)\\n        @test T ≈ 2π/n atol=1e-10\\n    end\\n\\n    @testset \\\"orbitalNRG with AstroCoord\\\" begin\\n        # Test with Cartesian\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        E = orbitalNRG(cart, μ)\\n        @test E < 0  # Bound orbit\\n        @test isfinite(E)\\n\\n        # Test with Keplerian\\n        kep = Keplerian(7000.0, 0.01, 0.0, 0.0, 0.0, 0.0)\\n        E = orbitalNRG(kep, μ)\\n        @test E < 0  # Bound orbit\\n        @test isfinite(E)\\n\\n        # Compare direct calculation with AstroCoord\\n        a = 7000.0\\n        E_direct = orbitalNRG(a, μ)\\n        E_coord = orbitalNRG(kep, μ)\\n        @test E_direct ≈ E_coord atol=1e-8\\n\\n        # Test energy formula: E = -μ/(2a)\\n        @test E ≈ -μ/(2*7000.0) atol=1e-8\\n    end\\n\\n    @testset \\\"angularMomentumVector with AstroCoord\\\" begin\\n        # Test with state vector\\n        u = [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]\\n        h_vec = angularMomentumVector(u)\\n        @test h_vec isa AbstractVector\\n        @test length(h_vec) == 3\\n        @test norm(h_vec) > 0\\n\\n        # Test with Cartesian\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        h_vec_cart = angularMomentumVector(cart, μ)\\n        @test h_vec ≈ h_vec_cart atol=1e-10\\n\\n        # Verify perpendicularity\\n        r = [7000.0, 0.0, 0.0]\\n        v = [0.0, 7.5, 0.0]\\n        @test abs(dot(h_vec, r)) < 1e-10\\n        @test abs(dot(h_vec, v)) < 1e-10\\n    end\\n\\n    @testset \\\"angularMomentumQuantity with AstroCoord\\\" begin\\n        # Test with state vector\\n        u = [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]\\n        h = angularMomentumQuantity(u)\\n        @test h > 0\\n        @test isfinite(h)\\n\\n        # Test with Cartesian\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        h_cart = angularMomentumQuantity(cart, μ)\\n        @test h ≈ h_cart atol=1e-10\\n\\n        # Verify it's the norm of the vector\\n        h_vec = angularMomentumVector(u)\\n        @test h ≈ norm(h_vec) atol=1e-10\\n    end\\nend\\n",
    "test/test_regularized_config.jl": "using AstroCoords\\nusing Test\\n\\n@testset \\\"RegularizedCoordinateConfig\\\" begin\\n    @testset \\\"Keyword constructor\\\" begin\\n        config = RegularizedCoordinateConfig(DU=1000.0, TU=100.0, W=0.5, t₀=0.0, flag_time=PhysicalTime())\\n        @test config.DU == 1000.0\\n        @test config.TU == 100.0\\n        @test config.W == 0.5\\n        @test config.t₀ == 0.0\\n        @test config.flag_time isa PhysicalTime\\n\\n        # Test default values\\n        config_default = RegularizedCoordinateConfig()\\n        @test config_default.DU == 0.0\\n        @test config_default.TU == 0.0\\n        @test config_default.W == 0.0\\n        @test config_default.t₀ == 0.0\\n        @test config_default.flag_time isa PhysicalTime\\n    end\\n\\n    @testset \\\"Constructor from state\\\" begin\\n        state = [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]\\n        μ = 398600.4418\\n        config = RegularizedCoordinateConfig(state, μ)\\n        @test config.DU > 0\\n        @test config.TU > 0\\n        @test config.W == 0.0\\n        @test config.t₀ == 0.0\\n\\n        # Test with additional parameters\\n        config2 = RegularizedCoordinateConfig(state, μ; W=0.5, t₀=100.0, flag_time=ConstantTime())\\n        @test config2.W == 0.5\\n        @test config2.t₀ == 100.0\\n        @test config2.flag_time isa ConstantTime\\n    end\\n\\n    @testset \\\"compute_characteristic_scales\\\" begin\\n        state = [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]\\n        μ = 398600.4418\\n        DU, TU = compute_characteristic_scales(state, μ)\\n        \\n        # DU should be the position magnitude\\n        @test DU ≈ 7000.0 atol=1e-10\\n        \\n        # TU should satisfy TU = sqrt(DU^3/μ)\\n        @test TU ≈ sqrt(DU^3/μ) atol=1e-6\\n        \\n        # Test with different state\\n        state2 = [10000.0, 5000.0, 2000.0, 1.0, 2.0, 3.0]\\n        DU2, TU2 = compute_characteristic_scales(state2, μ)\\n        expected_DU2 = sqrt(10000.0^2 + 5000.0^2 + 2000.0^2)\\n        @test DU2 ≈ expected_DU2 atol=1e-10\\n        @test TU2 ≈ sqrt(DU2^3/μ) atol=1e-6\\n    end\\n\\n    @testset \\\"compute_initial_phi\\\" begin\\n        state = [7000.0, 0.0, 0.0, 0.0, 7.5, 0.0]\\n        μ = 398600.4418\\n        config = RegularizedCoordinateConfig(state, μ)\\n        \\n        ϕ₀ = compute_initial_phi(state, μ, config)\\n        @test isfinite(ϕ₀)\\n        \\n        # Test with different orbit\\n        state2 = [7000.0, 3000.0, 1000.0, 2.0, 5.0, 1.0]\\n        ϕ₀_2 = compute_initial_phi(state2, μ, config)\\n        @test isfinite(ϕ₀_2)\\n        \\n        # Test with different W\\n        config_W = RegularizedCoordinateConfig(state, μ; W=1.0)\\n        ϕ₀_W = compute_initial_phi(state, μ, config_W)\\n        @test isfinite(ϕ₀_W)\\n    end\\n\\n    @testset \\\"Time formulation types\\\" begin\\n        @test PhysicalTime() isa AbstractTimeType\\n        @test ConstantTime() isa AbstractTimeType\\n        @test LinearTime() isa AbstractTimeType\\n        \\n        # Test in config\\n        config_phys = RegularizedCoordinateConfig(flag_time=PhysicalTime())\\n        config_const = RegularizedCoordinateConfig(flag_time=ConstantTime())\\n        config_lin = RegularizedCoordinateConfig(flag_time=LinearTime())\\n        \\n        @test config_phys.flag_time isa PhysicalTime\\n        @test config_const.flag_time isa ConstantTime\\n        @test config_lin.flag_time isa LinearTime\\n    end\\nend\\n",
    "test/test_core_types.jl": "using AstroCoords\\nusing Test\\nusing StaticArrays\\n\\n@testset \\\"Core Type System\\\" begin\\n    @testset \\\"Zero and zeros methods\\\" begin\\n        # Test zero for Cartesian\\n        cart_zero = zero(Cartesian{6, Float64})\\n        @test cart_zero isa SVector{6, Float64}\\n        @test all(cart_zero .== 0.0)\\n\\n        # Test zeros with dimensions\\n        cart_zeros = zeros(Cartesian{6, Float64}, 3)\\n        @test cart_zeros isa Vector\\n        @test length(cart_zeros) == 3\\n        @test all(iszero, cart_zeros)\\n\\n        # Test zeros with tuple dimensions\\n        cart_zeros_2d = zeros(Cartesian{6, Float64}, (2, 3))\\n        @test size(cart_zeros_2d) == (2, 3)\\n    end\\n\\n    @testset \\\"Convert methods\\\" begin\\n        # Test convert to same type\\n        cart1 = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        cart2 = convert(Cartesian, cart1)\\n        @test cart2 === cart1\\n\\n        # Test convert between coordinate types\\n        μ = 398600.4418\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        kep = Keplerian(cart, μ)\\n        cart_back = convert(Cartesian, kep)\\n        @test cart_back isa Cartesian\\n    end\\n\\n    @testset \\\"Transformation interface\\\" begin\\n        # Test IdentityTransformation\\n        id_trans = IdentityTransformation()\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n        @test id_trans(cart) === cart\\n\\n        # Test inv of IdentityTransformation\\n        @test inv(id_trans) === id_trans\\n\\n        # Test compose with identity\\n        trans = CartesianToKeplerian\\n        @test compose(trans, id_trans) === trans\\n        @test compose(id_trans, trans) === trans\\n        @test compose(id_trans, id_trans) === id_trans\\n    end\\n\\n    @testset \\\"ComposedTransformation\\\" begin\\n        μ = 398600.4418\\n        cart = Cartesian(7000.0, 0.0, 0.0, 0.0, 7.5, 0.0)\\n\\n        # Test composition operator\\n        trans = KeplerianToCartesian ∘ CartesianToKeplerian\\n        result = trans(cart, μ)\\n        @test result isa Cartesian\\n\\n        # Test inverse of composed transformation\\n        trans_composed = CartesianToKeplerian ∘ KeplerianToUSM7\\n        trans_inv = inv(trans_composed)\\n        @test trans_inv isa ComposedTransformation\\n    end\\n\\n    @testset \\\"Size methods\\\" begin\\n        # Test Size for Coordinate types\\n        @test Size(Cartesian{6}) == Size(6)\\n        @test Size(Keplerian{6}) == Size(6)\\n    end\\nend\\n",
    "test/runtests.jl": "using AstroCoords\\nusing Test\\n\\nusing DifferentiationInterface\\nusing Diffractor\\nusing Enzyme\\nusing FiniteDiff\\nusing ForwardDiff\\nusing Mooncake\\nusing PolyesterForwardDiff\\nusing Zygote\\n\\nusing Aqua\\nusing JET\\nusing AllocCheck\\n\\nconst _COORDINATE_SETS = [\\n    Cartesian,\\n    Delaunay,\\n    Keplerian,\\n    Milankovich,\\n    ModEq,\\n    Cylindrical,\\n    Spherical,\\n    USM7,\\n    USM6,\\n    USMEM,\\n    J2EqOE,\\n    EDromo,\\n    KustaanheimoStiefel,\\n    StiefelScheifele,\\n]\\n\\n@testset \\\"AstroCoords.jl\\\" begin\\n    include(\\\"test_anomalies.jl\\\")\\n    include(\\\"test_quantities.jl\\\")\\n    include(\\\"test_coordinate_changes.jl\\\")\\n    include(\\\"test_J2EqOE.jl\\\")\\n    include(\\\"test_EDromo.jl\\\")\\n    include(\\\"test_KS.jl\\\")\\n    include(\\\"test_StiefelScheifele.jl\\\")\\nend\\n\\n@testset \\\"Additional Coverage\\\" begin\\n    include(\\\"test_attitude_changes.jl\\\")\\n    include(\\\"test_utils.jl\\\")\\n    include(\\\"test_quantities_extende